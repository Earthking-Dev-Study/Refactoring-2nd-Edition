1. **반복문 쪼개기**(8.7절)로 변수 값을 누적시키는 부분을 분리한다.
1. **문장 슬라이드하기**(8.6절)로 변수 초기화 문장을 변수 값 누적 코드 바로 앞으로 옮긴다.
1. **함수 추출하기**(6.1절)로 적립 포인트 계산 부분을 별도 함수로 추출한다.
1. **변수 인라인하기**(6.4절)로 volumeCredits 변수를 제거한다.

## 2장

### 2-1 리팩터링 정의

리팩터링 [명사]: 소프트웨어의 겉보기 동작은 그대로 유지한 채, 코드를 이해하고 수정하기 쉽도록 내부 구조를 변경하는 기법

리팩터링 [동사]: 소프트웨어의 겉보기 동작은 그대로 유지한 채, 코드를 이해하고 수정하기 쉽도록 내부 구조를 변경하는 기법

- 코드를 정리하는 작업을 모조리 '리팩터링'이라고 하지 않는다, 특정한 방식에 따라 코드를 정리하는 것만이 리팩터링이다.

- 동작을 보존하는 작은 단계들을 거쳐 코드를 수정하고, 이러한 단계들을 순차적으로 연결하여 큰 변화를 만들어 낸다.

- 리팩터링하는 동안에는 코드가 항상 정상 작동하기 때문에(test로 정상작동 체크를 항상 해준다.) 전체 작업이 끝나지 않았더라도 언제든 멈출 수 있다.

- 만약 리팩토링하다가 도저히 안되겠으면 이전커밋으로 쉽게 돌아가서 다시 작업하면된다.

> 코드베이스를 정리하거나 구조를 바꾸는 모든 작업을 **재구성**이라는 포괄적인 용어로 표현하고, 리팩터링은 재구성 중 특수한 한 형태로 본다.

리팩터링을 정의할 때 '겉보기 동작(observable behavior)'라는 표현을 사용하였는데, 리팩터링을 하기 전과 후가 똑같이 동작해야 한다는 뜻이다. 그런데 함수 추출하기를 거치게 되면 콜스택이 달라져서 성능이 변할 수 있다.

한편, 리팩터링 과정에서 발견된 버그는 리팩터링 후에도 그대로 남아 있어야 한다.(단, 아무도 발견하지 못한 숨은 버그는 수정해도 괜찮다.)

리팩터링은 성능 최적화와 비슷한데, 목적이 다르다. 리팩터링의 목적은 코드를 이해하고 수정하기 쉽게 만드는 것이며 프로그램 성능은 좋아질 수도, 나빠질 수도 있다. 반면 성능 최적화는 오로지 속도 개선에만 신경 쓴다. 따라서 목표 성능에 반드시 도달해야 한다면 코드는 다루기에 더 어렵게 바뀔 수도 있음을 각오 해야한다.


## 용어

**함수 추출하기** : 코드 조각을 찾아 무슨 일을 하는지 파악한 다음, 독립된 함수로 추출하고 목적에 맞는 이름을 붙힌다.

- 코드를 언제 독립된 함수로 묶어야하는가?
    - 길이
        - 함수 하나가 한 화면을 넘어가면 안된다
    - 재사용성
        - 두 번 이상 사용될 코드는 함수로 만들고, 한 번만 쓰이는 코드는 인라인 상태로 놔두는 것이다.
    - **목적과 구현 분리**
        - 코드를 보고 무슨 일을 하는지 파악하는 데 한참이 걸린다면 그 부분을 함수로 추출한 뒤 '무슨 일'에 걸맞는 이름을 짓는다. 이렇게 한다면 나중에 코드를 다시 읽을 때 함수의 목적이 눈에 확 들어오고, 본문 코드(그 함수가 목적을 이루기 위해 구체적으로 수행하는 일)에 대해서는 더 이상 신경 쓸 일이 거의 없다. 즉, 함수명만으로도 함수가 어떠한 일을 하는지 확실히 알 수 있다.
    
    

## 토론 해볼것

### 주제
한편, 리팩터링 과정에서 발견된 버그는 리팩터링 후에도 그대로 남아 있어야 한다.(단, 아무도 발견하지 못한 숨은 버그는 수정해도 괜찮다.)

#### 내생각
리팩터링은 단순히 겉보기 동작은 그대로 유지한채, 코드를 이해하고 수정하기 쉽도록만 내부 구조를 변경하는 기법이니 버그를 수정하는것은 디버깅이기 때문에 이와는 다른 취급을 해야한다라는 뜻인가?

